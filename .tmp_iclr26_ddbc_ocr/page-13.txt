Under review as a conference paper at ICLR 2026

Algorithm 1 RVQ-ENCODE for an item embedding

Require: Item embedding E(é) € R%; semantic codebooks {C,...,C-)} withe = {el}, CR;
dedup indexer DepuP(i) € {1,...,Cx}
Ensure: Code indices z(i) = (z(i),... , 2) ()) and reconstruction E(i)
Ire Ei); Eeoa
2: for = 1to L —1do > semantic levels
3: 2 (i) — argmin§ |r — ef |[3 (tie-break: smallest index)
c€{1,....Ce}

4: BB+ 5 rer

(2)
~ © (i)
5: end for
6: 2") (i) — DEDUP(i) > non-semantic dedup level

: return z(i), E(i) = E

~

Algorithm 2 Constraint-aware order-agnostic decoding (inference)

Require: Observed item set bx; index maps u(j,é) and INVIDX(u) — (j, 2); code-domain valid sets
{VO (4; 23,<0)}; diffusion model po; horizon T
Ensure: Clean token matrix Z and completed bundle b
1: Initialize Z with tokens for Q, and for Qpag; set 2, <- [MASK] for all u € Qy
2: while there exists u € Qy with z, = [MASK] do

3 Choose a timestep t € {1,..., T} (e.g., t=T—s+1 at step s, or by a schedule)

4 for all u € Q, with z, = [MASK] do

5 (j, 2) — INVIDx(u)

6: a + po(- |Z =Z, t) categorical over {1,...,Ce} (no [MASK])
7: mask out invalids: z[c] < 0 for c ¢ VO (5; Zj,<e); 7+ 7/ D>. TIC]

8 Plu) 4

9: end for

10 Select a reveal set S C {u € Qy : zu = [MASK] } (e.g., top-k by max P(u), lowest-entropy, or

reveal ratio 7)
ll: for all u € S do

12: decode: 2, <— argmax P(u) (or sample with temperature/top-p)
13: clamp: 2, stays unmasked thereafter

14: end for

15: end while

16: 2 —Z

17: return Z©, b via ij = CopE2ITEM(z;,1:1) for all

We then specify exactly two sets:
mag = (1, UF U {ulG,0) Hr, — Meade = ulG, 2) :

By construction, Qfag A Qeoue = S and Ofag U Qeode = [VU]. Positions in Qpag are never masked;
corruption and prediction operate only on Qeode (including the dedup level =L).

=1,...,|b], €=1,...,L}. (12)

RVQ encoding pseudocode. We elucidate the pseudocode in Algorithm[I] specifying the encoding
for an item embedding.
Evaluation metric setting. To quantify the similarity between ppregict ANd Prarget, We Compute the

pairwise similarity S(t;, tj) for all tracks t; € ptarget and t; € ppredic. This setup forms a bipartite
graph, where the nodes correspond to tracks in the two playlists, and the edge weights represent
their pairwise similarity scores. The total similarity is defined as the Optimal Weighted Bipartite
Matching:

M* = argmax S S(ti,t;), (13)
(ti ,t3)EM
where M is a bijective mapping between prarget and ppredict-

Hungarian algorithm. We employ the Hungarian algorithm to solve the optimal matching problem.
The steps are detailed with pseudocode format in Algorithm B}

14
